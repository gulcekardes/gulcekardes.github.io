<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Gülce Kardeş – Puzzles</title>
  <link href="https://fonts.googleapis.com/css2?family=Volkorn:wght@400;700&family=Mate:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: Palatino, serif;
      background: #fafafa;
      overflow: hidden;
    }
    header {
      position: absolute; top: 0; width: 100%;
      background: white; padding: 1rem;
      text-align: center; font-family: Volkorn, serif;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      z-index: 10;
    }
    .nav-links a {
      margin: 0 10px; color: navy;
      text-decoration: none; font-size: 1.1rem;
    }
    .nav-links a.active { font-weight: bold; }
    canvas { display: block; }
  </style>
</head>
<body>
  <header>
    <div class="nav-links">
      <a href="../index.html">Home</a>
      <a href="#" class="active">Puzzles</a>
      <a href="https://scholar.google.com/citations?user=-io3rR0AAAAJ">Google Scholar</a>
    </div>
  </header>

  <canvas id="iso"></canvas>

  <script>
  // JSON definition of the 7 Soma pieces
  const pieces = [
    { name:"V", coords:[[0,0,0],[0,0,1],[0,1,0]],             color:"#e6194B" },
    { name:"L", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,0]],     color:"#3cb44b" },
    { name:"T", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,1]],     color:"#4363d8" },
    { name:"Z", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,0]],     color:"#f58231" },
    { name:"A", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,1]],     color:"#911eb4" },
    { name:"B", coords:[[0,0,0],[0,0,1],[0,1,0],[1,1,0]],     color:"#46f0f0" },
    { name:"P", coords:[[0,0,0],[0,0,1],[0,1,1],[0,1,2]],     color:"#f032e6" }
  ];

  // The three faces we draw per cube (top, left, right)
  const faces = [
    { verts:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]], shade:1.00 },
    { verts:[[0,0,0],[0,1,0],[0,1,1],[0,0,1]], shade:0.85 },
    { verts:[[1,0,0],[1,0,1],[1,1,1],[1,1,0]], shade:0.70 }
  ];

  const canvas = document.getElementById("iso"),
        ctx    = canvas.getContext("2d");
  let w, h, cx, cy;

  // rotation angles
  let rotX = Math.PI/6,  // 30°
      rotY = -Math.PI/6; // -30°

  // piece offsets in world coords (so they don’t overlap)
  const spacing = 5;
  const cols = 4;
  const offsets = pieces.map((_,i) => ({
    x: (i % cols) * spacing,
    y: 0,
    z: Math.floor(i / cols) * spacing
  }));

  // project a 3D point to 2D
  function project([x,y,z]) {
    // rotate Y
    const cY = Math.cos(rotY), sY = Math.sin(rotY);
    let dx = cY*x + sY*z,
        dz = -sY*x + cY*z,
        dy = y;
    // rotate X
    const cX = Math.cos(rotX), sX = Math.sin(rotX);
    let dy2 = cX*dy - sX*dz,
        dz2 = sX*dy + cX*dz;
    const scale = 40;
    return {
      x: cx + dx*scale,
      y: cy - dy2*scale,
      depth: dz2
    };
  }

  // shade a hex toward white
  function shadeColor(hex, shade) {
    const r = parseInt(hex.slice(1,3),16),
          g = parseInt(hex.slice(3,5),16),
          b = parseInt(hex.slice(5,7),16);
    const nr = Math.round(r*shade + 255*(1-shade)),
          ng = Math.round(g*shade + 255*(1-shade)),
          nb = Math.round(b*shade + 255*(1-shade));
    return `rgb(${nr},${ng},${nb})`;
  }

  // draw one cube at world coord
  function drawCube(wx,wy,wz,color) {
    faces.forEach(f=>{
      const pts = f.verts.map(v=> project([wx+v[0], wy+v[1], wz+v[2]]));
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      pts.slice(1).forEach(p=> ctx.lineTo(p.x,p.y));
      ctx.closePath();
      ctx.fillStyle = shadeColor(color,f.shade);
      ctx.fill();
      ctx.strokeStyle = "#333";
      ctx.stroke();
    });
  }

  // full redraw
  function draw() {
    ctx.clearRect(0,0,w,h);

    // collect all cubes with depth
    const toDraw = [];
    pieces.forEach((p,i)=>{
      const off = offsets[i];
      p.coords.forEach(c=>{
        const world = [c[0]+off.x, c[1]+off.y, c[2]+off.z];
        const proj = project(world);
        toDraw.push({ world, color:p.color, depth:proj.depth });
      });
    });

    // painter’s algorithm
    toDraw.sort((a,b)=> a.depth - b.depth);
    toDraw.forEach(d=> drawCube(...d.world, d.color));

    // labels
    ctx.fillStyle = "black";
    ctx.font = "bold 16px Palatino, serif";
    pieces.forEach((p,i)=>{
      const off = offsets[i];
      const n = p.coords.length;
      // compute centroid in world coords
      const cx3 = p.coords.reduce((s,pt)=> s+pt[0],0)/n + off.x;
      const cy3 = p.coords.reduce((s,pt)=> s+pt[1],0)/n + 1 + off.y;
      const cz3 = p.coords.reduce((s,pt)=> s+pt[2],0)/n + off.z;
      const pr = project([cx3,cy3,cz3]);
      ctx.fillText(p.name, pr.x-8, pr.y);
    });
  }

  // resize canvas
  function resize(){
    w = canvas.width  = innerWidth;
    h = canvas.height = innerHeight;
    cx = w/2;
    cy = h/2 + 40;
    draw();
  }

  // drag to rotate
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener("mousedown",e=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY;
  });
  window.addEventListener("mousemove",e=>{
    if(!dragging) return;
    const dx = e.clientX - lastX,
          dy = e.clientY - lastY;
    rotY += dx*0.01;
    rotX += dy*0.01;
    lastX = e.clientX; lastY = e.clientY;
    draw();
  });
  window.addEventListener("mouseup",()=>dragging=false);
  window.addEventListener("resize",resize);

  resize();
  </script>
</body>
</html>
