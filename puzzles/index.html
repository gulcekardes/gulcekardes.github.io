<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Gülce Kardeş – Soma Cube Solver</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family: Palatino, serif; background: #fafafa; }
    header { background: white; padding: 1rem; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 10; }
    .nav-links a { margin: 0 10px; color: navy; text-decoration: none; font-size: 1.1rem; }
    .nav-links a.active { font-weight: bold; }
    main { padding: 1rem; }
    h2 { margin: 1.5rem 0 0.5rem; font-size: 1.5rem; text-align: center; }
    #pieces { display: flex; flex-wrap: wrap; gap: 20px; }
    figure { width: 200px; text-align: center; }
    figcaption { margin-bottom: 4px; font-weight: bold; }
    .rotate-btns { margin-top: 4px; }
    .rotate-btns button { margin: 0 4px; cursor: pointer; }
    canvas.piece { width: 200px; height: 200px; background: white; cursor: pointer; border: 2px solid transparent; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
    canvas.piece.selected { border-color: crimson; }
    #solver { display: block; width: 400px; height: 400px; margin: 1rem auto; background: white; cursor: default; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
    #solver-controls { text-align: center; margin: 0.5rem 0; }
    #solver-controls button { margin: 0 8px; cursor: pointer; }
  </style>
</head>
<body>
  <header>
    <div class="nav-links">
      <a href="../index.html">Home</a>
      <a href="#" class="active">Puzzles</a>
      <a href="https://scholar.google.com/citations?user=-io3rR0AAAAJ">Google Scholar</a>
    </div>
  </header>
  <main>
    <h2>The 7 Soma Pieces</h2>
    <div id="pieces"></div>
    <h2>Soma Cube Solver</h2>
    <canvas id="solver" width="400" height="400"></canvas>
    <div id="solver-controls">
      <button id="rotXneg">↑</button>
      <button id="rotXpos">↓</button>
      <button id="rotYneg">←</button>
      <button id="rotYpos">→</button>
    </div>
    <p style="text-align:center; color:#555;">
      1) Click a cubie in a piece to select its anchor.<br>
      2) Hover over solver to see highlighted cell.<br>
      3) Click cell to place; click occupied cell with no anchor to remove.
    </p>
  </main>
  <script>
  // --- 3D rendering setup ---
  const faces = [
    { verts:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]], normal:[0,1,0], shade:1.00 },
    { verts:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], normal:[0,0,1], shade:0.85 },
    { verts:[[1,0,0],[1,0,1],[1,1,1],[1,1,0]], normal:[1,0,0], shade:0.75 },
    { verts:[[0,0,0],[0,0,1],[0,1,1],[0,1,0]], normal:[-1,0,0], shade:0.65 }
  ];
  function shadeColor(hex,s){
    const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
    return `rgba(${Math.round(r*s+255*(1-s))},${Math.round(g*s+255*(1-s))},${Math.round(b*s+255*(1-s))},1)`;
  }

  // --- Piece data ---
  const pieces = [
    { name:'V', coords:[[0,0,0],[0,0,1],[0,1,0]], color:'#e6194B' },
    { name:'L', coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,0]], color:'#3cb44b' },
    { name:'T', coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,1]], color:'#4363d8' },
    { name:'P', coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,0]], color:'#f58231' },
    { name:'A', coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,1]], color:'#911eb4' },
    { name:'B', coords:[[0,0,0],[0,0,1],[0,1,0],[1,1,0]], color:'#46f0f0' },
    { name:'Z', coords:[[0,0,0],[0,0,1],[0,1,1],[0,1,2]], color:'#f032e6' }
  ];
  pieces.forEach(p => {
    const mins = p.coords.reduce((m,c)=>[Math.min(m[0],c[0]),Math.min(m[1],c[1]),Math.min(m[2],c[2])],[Infinity,Infinity,Infinity]);
    p.norm = p.coords.map(c=>[c[0]-mins[0], c[1]-mins[1], c[2]-mins[2]]);
  });

  let selected=null, selectedAnchor=null;
  const rotStep = Math.PI/12;
  const piecesDiv = document.getElementById('pieces');

  // --- Project a piece point ---
  function projectPiece(pt, rotX, rotY, offset){
    let [x,y,z] = pt;
    x -= offset[0]; y -= offset[1];
    const cY=Math.cos(rotY), sY=Math.sin(rotY);
    let dx = cY*x + sY*z, dz = -sY*x + cY*z;
    const cX=Math.cos(rotX), sX=Math.sin(rotX);
    let dy = cX*y - sX*dz, dz2 = sX*y + cX*dz;
    return { x:100 + dx*60, y:100 - dy*60, depth: dz2 };
  }

  // --- Render piece canvases ---
  pieces.forEach((p, idx) => {
    const fig = document.createElement('figure');
    const cap = document.createElement('figcaption'); cap.textContent = p.name;
    const cv = document.createElement('canvas'); cv.className = 'piece'; cv.width = cv.height = 200;
    const btns = document.createElement('div'); btns.className='rotate-btns';
    btns.innerHTML = '<button>↺</button><button>↻</button>';
    fig.append(cap, cv, btns);
    piecesDiv.append(fig);

    const ctx = cv.getContext('2d');
    let rotX = Math.PI/6, rotY = -Math.PI/6;
    const n = p.norm.length;
    const offset = [
      p.norm.reduce((s,c)=>s+c[0],0)/n,
      p.norm.reduce((s,c)=>s+c[1],0)/n,
      p.norm.reduce((s,c)=>s+c[2],0)/n
    ];

    function draw(){
      ctx.clearRect(0,0,200,200);
      p.norm
        .map(c0=>({c0,depth:projectPiece(c0,rotX,rotY,offset).depth}))
        .sort((a,b)=>a.depth-b.depth)
        .forEach(d=>faces.forEach(f=>{
          const pts = f.verts.map(v=>
            projectPiece([d.c0[0]+v[0], d.c0[1]+v[1], d.c0[2]+v[2]], rotX, rotY, offset)
          );
          ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
          pts.slice(1).forEach(p2=>ctx.lineTo(p2.x,p2.y));
          ctx.closePath();
          ctx.fillStyle = shadeColor(p.color,f.shade);
          ctx.fill(); ctx.strokeStyle='#333'; ctx.stroke();
        }));
      if(selected===idx && selectedAnchor!=null){
        const c0 = p.norm[selectedAnchor];
        const pr = projectPiece([c0[0]+0.5,c0[1]+0.5,c0[2]+0.5], rotX, rotY, offset);
        ctx.beginPath(); ctx.arc(pr.x,pr.y,6,0,2*Math.PI);
        ctx.strokeStyle='crimson'; ctx.lineWidth=2; ctx.stroke();
      }
    }
    draw();

    // piece rotate buttons
    btns.children[0].addEventListener('click',()=>{ rotY -= rotStep; draw(); });
    btns.children[1].addEventListener('click',()=>{ rotY += rotStep; draw(); });

    // click to select anchor
    cv.addEventListener('click', e => {
      const r = cv.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      let best=null, bd=Infinity;
      p.norm.forEach((c0,i)=>{
        const pr = projectPiece([c0[0]+0.5,c0[1]+0.5,c0[2]+0.5], rotX, rotY, offset);
        const d = (pr.x-mx)**2 + (pr.y-my)**2;
        if(d<bd){ bd=d; best=i; }
      });
      selected = idx; selectedAnchor = best;
      document.querySelectorAll('canvas.piece').forEach(c=>c.classList.remove('selected'));
      cv.classList.add('selected'); draw();
    });
  });

  // --- Solver setup ---
  const solver = document.getElementById('solver');
  const sCtx = solver.getContext('2d');
  solver.width = solver.height = 400;
  let sRotX = Math.PI/6, sRotY = -Math.PI/6;
  const occupied = {}, placements = [];
  let hoverCell = null;

  function projectG([x,y,z]){
    const cY=Math.cos(sRotY), sY=Math.sin(sRotY);
    let dx = cY*x + sY*z, dz = -sY*x + cY*z;
    const cX=Math.cos(sRotX), sX=Math.sin(sRotX);
    let dy = cX*y - sX*dz, dz2 = sX*y + cX*dz;
    return { x:200+dx*50, y:200-dy*50, depth: dz2 };
  }

  function drawSolver(){
    sCtx.clearRect(0,0,400,400);
    sCtx.strokeStyle = '#888';
    // draw grid
    for(let i=0;i<=3;i++) for(let j=0;j<=3;j++){
      [[0,i,j,3,i,j],[i,0,j,i,3,j],[i,j,0,i,j,3]].forEach(([x0,y0,z0,x1,y1,z1])=>{
        const p0 = projectG([x0,y0,z0]), p1 = projectG([x1,y1,z1]);
        sCtx.beginPath(); sCtx.moveTo(p0.x,p0.y); sCtx.lineTo(p1.x,p1.y); sCtx.stroke();
      });
    }
    // hover highlight
    if(hoverCell){
      const pr = projectG([hoverCell[0]+0.5, hoverCell[1]+0.5, hoverCell[2]+0.5]);
      sCtx.beginPath(); sCtx.arc(pr.x,pr.y,10,0,2*Math.PI);
      sCtx.fillStyle = 'rgba(200,200,200,0.4)'; sCtx.fill();
    }
    // draw pieces
    const all = [];
    placements.forEach(pl => {
      pieces[pl.idx].norm.forEach(c0 => {
        const wx = pl.origin[0]+c0[0], wy = pl.origin[1]+c0[1], wz = pl.origin[2]+c0[2];
        all.push({ wx, wy, wz, depth: projectG([wx,wy,wz]).depth, color: pieces[pl.idx].color });
      });
    });
    all.sort((a,b)=>a.depth-b.depth).forEach(d=>faces.forEach(f=>{
      const pts = f.verts.map(v=>projectG([d.wx+v[0], d.wy+v[1], d.wz+v[2]]));
      sCtx.beginPath(); sCtx.moveTo(pts[0].x,pts[0].y);
      pts.slice(1).forEach(p2=>sCtx.lineTo(p2.x,p2.y));
      sCtx.closePath(); sCtx.fillStyle=shadeColor(d.color,f.shade);
      sCtx.fill(); sCtx.strokeStyle='#333'; sCtx.stroke();
    }));
  }

  // hover logic
  solver.addEventListener('mousemove', e => {
    const r = solver.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    let best=null, bd=Infinity;
    for(let x=0;x<3;x++) for(let y=0;y<3;y++) for(let z=0;z<3;z++){
      const pr = projectG([x+0.5,y+0.5,z+0.5]);
      const d = (pr.x-mx)**2 + (pr.y-my)**2;
      if(d<bd){ bd=d; best=[x,y,z]; }
    }
    hoverCell = best; drawSolver();
  });
  solver.addEventListener('mouseleave', () => { hoverCell = null; drawSolver(); });

  // rotate controls
  document.getElementById('rotXneg').addEventListener('click', ()=>{ sRotX -= rotStep; drawSolver(); });
  document.getElementById('rotXpos').addEventListener('click', ()=>{ sRotX += rotStep; drawSolver(); });
  document.getElementById('rotYneg').addEventListener('click', ()=>{ sRotY -= rotStep; drawSolver(); });
  document.getElementById('rotYpos').addEventListener('click', ()=>{ sRotY += rotStep; drawSolver(); });

  // click to place or remove
  solver.addEventListener('click', e => {
    const r = solver.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    let bestCell=null, bd=Infinity;
    for(let x=0;x<3;x++) for(let y=0;y<3;y++) for(let z=0;z<3;z++){
      const pr = projectG([x+0.5,y+0.5,z+0.5]);
      const d = (pr.x-mx)**2 + (pr.y-my)**2;
      if(d<bd){ bd=d; bestCell=[x,y,z]; }
    }
    if(!bestCell) return;
    const key = bestCell.join(',');
    // removal
    if(occupied[key]!=null && (selected===null||selectedAnchor===null)){
      const rem = occupied[key];
      for(const k in occupied) if(occupied[k]===rem) delete occupied[k];
      placements.splice(placements.findIndex(pl=>pl.idx===rem),1);
      drawSolver(); return;
    }
    // placement
    if(selected!=null && selectedAnchor!=null){
      const c0 = pieces[selected].norm[selectedAnchor];
      const origin = [bestCell[0]-c0[0], bestCell[1]-c0[1], bestCell[2]-c0[2]];
      for(const c of pieces[selected].norm){
        const wx=origin[0]+c[0], wy=origin[1]+c[1], wz=origin[2]+c[2];
        if(wx<0||wx>2||wy<0||wy>2||wz<0||wz>2) return;
        if(occupied[[wx,wy,wz].join(',')]!=null) return;
      }
      pieces[selected].norm.forEach(c=>{
        const wx=origin[0]+c[0], wy=origin[1]+c[1], wz=origin[2]+c[2];
        occupied[[wx,wy,wz].join(',')] = selected;
      });
      placements.push({idx:selected, origin});
      selected = null; selectedAnchor = null;
      document.querySelectorAll('canvas.piece').forEach(c=>c.classList.remove('selected'));
      drawSolver();
    }
  });

  // initial draw
  drawSolver();
  </script>
</body>
</html>
