<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Gülce Kardeş – Puzzles</title>
  <link href="https://fonts.googleapis.com/css2?family=Mate:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: Palatino, serif;
      background: #fafafa;
      overflow-y: scroll;
    }
    header {
      background: white;
      padding: 1rem;
      text-align: center;
      font-family: Palatino, serif;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: sticky; top: 0;
      z-index: 10;
    }
    .nav-links a {
      margin: 0 10px;
      color: navy;
      text-decoration: none;
      font-size: 1.1rem;
      font-family: Palatino, serif;
    }
    .nav-links a.active { font-weight: bold; }
    #pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 1rem;
      justify-content: flex-start;
    }
    figure {
      width: 200px;
      text-align: center;
      margin: 0;
    }
    figcaption {
      font-family: Palatino, serif;
      font-weight: bold;
      margin-bottom: 5px;
    }
    canvas {
      width: 200px;
      height: 200px;
      display: block;
      cursor: grab;
      background: white;
    }
    canvas:active { cursor: grabbing; }
  </style>
</head>
<body>
  <header>
    <div class="nav-links">
      <a href="../index.html">Home</a>
      <a href="#" class="active">Puzzles</a>
      <a href="https://scholar.google.com/citations?user=-io3rR0AAAAJ">Google Scholar</a>
    </div>
  </header>

  <div id="pieces"></div>

  <script>
  // --- JSON definition (with Z ↔ P swapped) ---
  const pieces = [
    { name:"V", coords:[[0,0,0],[0,0,1],[0,1,0]],             color:"#e6194B" },
    { name:"L", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,0]],     color:"#3cb44b" },
    { name:"T", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,1]],     color:"#4363d8" },
    { name:"P", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,0]],     color:"#f58231" }, // was Z
    { name:"A", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,1]],     color:"#911eb4" },
    { name:"B", coords:[[0,0,0],[0,0,1],[0,1,0],[1,1,0]],     color:"#46f0f0" },
    { name:"Z", coords:[[0,0,0],[0,0,1],[0,1,1],[0,1,2]],     color:"#f032e6" }  // was P
  ];

  // faces to draw: top, front, right, left with normals & shading
  const faces = [
    { verts:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]], normal:[0,1,0], shade:1.00 },  // top
    { verts:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], normal:[0,0,1], shade:0.85 },  // front
    { verts:[[1,0,0],[1,0,1],[1,1,1],[1,1,0]], normal:[1,0,0], shade:0.75 },  // right
    { verts:[[0,0,0],[0,0,1],[0,1,1],[0,1,0]], normal:[-1,0,0], shade:0.65 }  // left
  ];

  const container = document.getElementById("pieces");

  // shade a hex toward white
  function shadeColor(hex,s){
    const r=parseInt(hex.slice(1,3),16),
          g=parseInt(hex.slice(3,5),16),
          b=parseInt(hex.slice(5,7),16);
    const nr=Math.round(r*s+255*(1-s)),
          ng=Math.round(g*s+255*(1-s)),
          nb=Math.round(b*s+255*(1-s));
    return `rgb(${nr},${ng},${nb})`;
  }

  // build each piece
  pieces.forEach(p => {
    const fig = document.createElement("figure"),
          cap = document.createElement("figcaption"),
          canvas = document.createElement("canvas");
    cap.textContent = p.name;
    canvas.width = 200; canvas.height = 200;
    fig.appendChild(cap);
    fig.appendChild(canvas);
    container.appendChild(fig);

    const ctx = canvas.getContext("2d");
    const coordSet = new Set(p.coords.map(c=>c.join(",")));

    // centroid for centering
    const n = p.coords.length;
    const cx3 = p.coords.reduce((s,c)=>s+c[0],0)/n,
          cy3 = p.coords.reduce((s,c)=>s+c[1],0)/n,
          cz3 = p.coords.reduce((s,c)=>s+c[2],0)/n;

    // rotation
    let rotX=Math.PI/6, rotY=-Math.PI/6;
    let dragging=false, lastX=0, lastY=0;

    function project([x,y,z]){
      // translate to center
      x -= cx3; y -= cy3; z -= cz3;
      // rotate Y
      const cY=Math.cos(rotY), sY=Math.sin(rotY);
      let dx = cY*x + sY*z, dz = -sY*x + cY*z, dy=y;
      // rotate X
      const cX=Math.cos(rotX), sX=Math.sin(rotX);
      let dy2 = cX*dy - sX*dz, dz2 = sX*dy + cX*dz;
      const scale = 40;
      return {
        x: canvas.width/2 + dx*scale,
        y: canvas.height/2 - dy2*scale,
        depth: dz2
      };
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // collect all cube centers with depth
      const cells = p.coords.map(c0 => {
        const pr = project(c0);
        return { orig:c0, depth:pr.depth };
      });
      // sort back→front
      cells.sort((a,b)=> a.depth - b.depth);

      // draw faces of each cube
      cells.forEach(cData => {
        faces.forEach(f => {
          // skip if neighbor exists (internal face)
          const nb = [
            cData.orig[0]+f.normal[0],
            cData.orig[1]+f.normal[1],
            cData.orig[2]+f.normal[2]
          ].join(",");
          if(coordSet.has(nb)) return;

          // draw polygon
          const pts = f.verts.map(v=>
            project([
              cData.orig[0]+v[0],
              cData.orig[1]+v[1],
              cData.orig[2]+v[2]
            ])
          );
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(p2=>ctx.lineTo(p2.x,p2.y));
          ctx.closePath();
          ctx.fillStyle = shadeColor(p.color, f.shade);
          ctx.fill();
          ctx.strokeStyle = "#333";
          ctx.stroke();
        });
      });
    }

    // drag to rotate
    canvas.addEventListener("mousedown", e=>{
      dragging=true; lastX=e.clientX; lastY=e.clientY;
    });
    window.addEventListener("mousemove", e=>{
      if(!dragging) return;
      rotY += (e.clientX-lastX)*0.01;
      rotX += (e.clientY-lastY)*0.01;
      lastX=e.clientX; lastY=e.clientY;
      draw();
    });
    window.addEventListener("mouseup", ()=>dragging=false);
    window.addEventListener("mouseleave", ()=>dragging=false);

    draw();
  });
  </script>
</body>
</html>
