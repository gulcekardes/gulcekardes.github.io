<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Gülce Kardeş – Puzzles</title>
  <link href="https://fonts.googleapis.com/css2?family=Mate:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: Palatino, serif;
      background: #fafafa;
      overflow-y: scroll;
    }
    header {
      background: white;
      padding: 1rem;
      text-align: center;
      font-family: Palatino, serif;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: sticky; top: 0;
      z-index: 10;
    }
    .nav-links a {
      margin: 0 10px;
      color: navy;
      text-decoration: none;
      font-size: 1.1rem;
      font-family: Palatino, serif;
    }
    .nav-links a.active { font-weight: bold; }
    #pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 1rem;
      justify-content: flex-start;
    }
    figure {
      width: 200px;
      text-align: center;
      margin: 0;
    }
    figcaption {
      font-family: Palatino, serif;
      font-weight: bold;
      margin-bottom: 5px;
    }
    canvas {
      width: 200px;
      height: 200px;
      display: block;
      cursor: grab;
      background: white;
    }
    canvas:active { cursor: grabbing; }
  </style>
</head>
<body>
  <header>
    <div class="nav-links">
      <a href="../index.html">Home</a>
      <a href="#" class="active">Puzzles</a>
      <a href="https://scholar.google.com/citations?user=-io3rR0AAAAJ">Google Scholar</a>
    </div>
  </header>

  <div id="pieces"></div>

  <script>
  // --- JSON definition of your 7 Soma pieces (Z ↔ P swapped) ---
  const pieces = [
    { name:"V", coords:[[0,0,0],[0,0,1],[0,1,0]],             color:"#e6194B" },
    { name:"L", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,0]],     color:"#3cb44b" },
    { name:"T", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,1]],     color:"#4363d8" },
    { name:"P", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,0]],     color:"#f58231" }, // was Z
    { name:"A", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,1]],     color:"#911eb4" },
    { name:"B", coords:[[0,0,0],[0,0,1],[0,1,0],[1,1,0]],     color:"#46f0f0" },
    { name:"Z", coords:[[0,0,0],[0,0,1],[0,1,1],[0,1,2]],     color:"#f032e6" }  // was P
  ];

  // the three faces we can see (top, left, right) plus their normals
  const faces = [
    { verts:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]], normal:[0,1,0], shade:1.00 },
    { verts:[[0,0,0],[0,1,0],[0,1,1],[0,0,1]], normal:[-1,0,0], shade:0.85 },
    { verts:[[1,0,0],[1,0,1],[1,1,1],[1,1,0]], normal:[1,0,0], shade:0.70 }
  ];

  const container = document.getElementById("pieces");

  function shadeColor(hex, s) {
    const r=parseInt(hex.slice(1,3),16),
          g=parseInt(hex.slice(3,5),16),
          b=parseInt(hex.slice(5,7),16);
    const nr=Math.round(r*s + 255*(1-s)),
          ng=Math.round(g*s + 255*(1-s)),
          nb=Math.round(b*s + 255*(1-s));
    return `rgb(${nr},${ng},${nb})`;
  }

  // build each piece’s <figure> + canvas + drawing logic
  pieces.forEach(p => {
    const fig = document.createElement("figure");
    const cap = document.createElement("figcaption");
    cap.textContent = p.name;
    fig.appendChild(cap);

    const canvas = document.createElement("canvas");
    canvas.width = 200; canvas.height = 200;
    fig.appendChild(canvas);
    container.appendChild(fig);

    const ctx = canvas.getContext("2d");
    // make a lookup for adjacency
    const coordsSet = new Set(p.coords.map(c=>c.join(",")));
    // compute centroid for centering
    const n = p.coords.length;
    let sx=0, sy=0, sz=0;
    p.coords.forEach(c=>{ sx+=c[0]; sy+=c[1]; sz+=c[2]; });
    const center = [sx/n, sy/n, sz/n];

    // rotation state
    let rotX=Math.PI/6, rotY=-Math.PI/6;
    let dragging=false, lastX=0, lastY=0;

    // project a 3D point to 2D canvas
    function project(pt){
      let [x,y,z]=pt;
      const cY=Math.cos(rotY), sY=Math.sin(rotY);
      let dx=cY*x + sY*z, dz=-sY*x + cY*z, dy=y;
      const cX=Math.cos(rotX), sX=Math.sin(rotX);
      let dy2=cX*dy - sX*dz, dz2=sX*dy + cX*dz;
      const scale=40;
      return {
        x: canvas.width/2 + dx*scale,
        y: canvas.height/2 - dy2*scale,
        depth: dz2
      };
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // collect cubes with depth for sorting
      const list = [];
      p.coords.forEach(c0 => {
        const [lx,ly,lz] = [c0[0]-center[0], c0[1]-center[1], c0[2]-center[2]];
        const pr = project([lx,ly,lz]);
        list.push({ lx,ly,lz, orig:c0, depth:pr.depth });
      });
      // painter’s sort
      list.sort((a,b)=>a.depth - b.depth);
      // draw each cube’s faces if exposed
      list.forEach(d => {
        faces.forEach(f => {
          const [nx,ny,nz] = f.normal;
          const neighbour = [d.orig[0]+nx, d.orig[1]+ny, d.orig[2]+nz].join(",");
          if (coordsSet.has(neighbour)) return;  // skip internal faces
          const pts = f.verts.map(v => project([
            d.lx + v[0], d.ly + v[1], d.lz + v[2]
          ]));
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          pts.slice(1).forEach(p2=> ctx.lineTo(p2.x,p2.y));
          ctx.closePath();
          ctx.fillStyle = shadeColor(p.color, f.shade);
          ctx.fill();
          ctx.strokeStyle = "#333";
          ctx.stroke();
        });
      });
    }

    // mouse-driven rotate
    canvas.addEventListener("mousedown", e=>{
      dragging = true; lastX=e.clientX; lastY=e.clientY;
    });
    window.addEventListener("mousemove", e=>{
      if (!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      rotY += dx*0.01;
      rotX += dy*0.01;
      lastX=e.clientX; lastY=e.clientY;
      draw();
    });
    window.addEventListener("mouseup", ()=>dragging=false);
    window.addEventListener("mouseleave", ()=>dragging=false);

    draw();
  });
  </script>
</body>
</html>
