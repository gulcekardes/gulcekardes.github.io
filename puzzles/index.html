<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Gülce Kardeş – Soma Cube Solver</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: Palatino, serif;
      background: #fafafa;
    }
    header {
      background: white;
      padding: 1rem;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      position: sticky; top: 0; z-index: 10;
    }
    .nav-links a {
      margin: 0 10px;
      color: navy;
      text-decoration: none;
      font-size: 1.1rem;
    }
    .nav-links a.active { font-weight: bold; }
    main {
      padding: 1rem;
    }
    h2 {
      margin: 1.5rem 0 0.5rem;
      font-size: 1.5rem;
      text-align: center;
    }
    #pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    figure {
      width: 200px;
      text-align: center;
    }
    figcaption {
      margin-bottom: 4px;
      font-weight: bold;
    }
    canvas.piece {
      width: 200px;
      height: 200px;
      background: white;
      cursor: pointer;
      border: 2px solid transparent;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    canvas.piece.selected {
      border-color: crimson;
    }
    #solver {
      display: block;
      width: 400px;
      height: 400px;
      margin: 1rem auto;
      background: white;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #solver:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <header>
    <div class="nav-links">
      <a href="../index.html">Home</a>
      <a href="#" class="active">Puzzles</a>
      <a href="https://scholar.google.com/citations?user=-io3rR0AAAAJ">Google Scholar</a>
    </div>
  </header>

  <main>
    <h2>The 7 Soma Pieces</h2>
    <div id="pieces"></div>

    <h2>Soma Cube Solver</h2>
    <canvas id="solver" width="400" height="400"></canvas>
  </main>

  <script>
  // --- Pieces (Z↔P swapped) ---
  const pieces = [
    { name:"V", coords:[[0,0,0],[0,0,1],[0,1,0]],          color:"#e6194B" },
    { name:"L", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,0]],  color:"#3cb44b" },
    { name:"T", coords:[[0,0,0],[0,0,1],[0,0,2],[0,1,1]],  color:"#4363d8" },
    { name:"P", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,0]],  color:"#f58231" },
    { name:"A", coords:[[0,0,0],[0,0,1],[0,1,0],[1,0,1]],  color:"#911eb4" },
    { name:"B", coords:[[0,0,0],[0,0,1],[0,1,0],[1,1,0]],  color:"#46f0f0" },
    { name:"Z", coords:[[0,0,0],[0,0,1],[0,1,1],[0,1,2]],  color:"#f032e6" }
  ];

  // faces to draw
  const faces = [
    { verts:[[0,1,0],[1,1,0],[1,1,1],[0,1,1]], normal:[0,1,0], shade:1.00 },
    { verts:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], normal:[0,0,1], shade:0.85 },
    { verts:[[1,0,0],[1,0,1],[1,1,1],[1,1,0]], normal:[1,0,0], shade:0.75 },
    { verts:[[0,0,0],[0,0,1],[0,1,1],[0,1,0]], normal:[-1,0,0], shade:0.65 }
  ];

  function shadeColor(hex,s){
    const r=parseInt(hex.slice(1,3),16),
          g=parseInt(hex.slice(3,5),16),
          b=parseInt(hex.slice(5,7),16);
    return `rgb(${Math.round(r*s+255*(1-s))},${Math.round(g*s+255*(1-s))},${Math.round(b*s+255*(1-s))})`;
  }

  // --- Render pieces & handle selection ---
  let selected = null;
  const piecesDiv = document.getElementById("pieces");

  pieces.forEach((p, idx)=>{
    // normalize so min coord is at 0
    const mins = p.coords.reduce((m,c)=>[Math.min(m[0],c[0]),Math.min(m[1],c[1]),Math.min(m[2],c[2])],[Infinity,Infinity,Infinity]);
    p.norm = p.coords.map(c=>[c[0]-mins[0],c[1]-mins[1],c[2]-mins[2]]);

    const fig = document.createElement("figure");
    const cap = document.createElement("figcaption");
    cap.textContent = p.name;
    fig.append(cap);

    const cv = document.createElement("canvas");
    cv.className = "piece";
    cv.width = 400; cv.height = 400;
    fig.append(cv);
    piecesDiv.append(fig);

    const ctx = cv.getContext("2d");
    // compute centroid
    const n = p.norm.length;
    const cx3 = p.norm.reduce((s,c)=>s+c[0],0)/n,
          cy3 = p.norm.reduce((s,c)=>s+c[1],0)/n,
          cz3 = p.norm.reduce((s,c)=>s+c[2],0)/n;

    let rotX=Math.PI/6, rotY=-Math.PI/6;
    function project(pt){
      let [x,y,z]=pt;
      x-=cx3; y-=cy3; z-=cz3;
      const cY=Math.cos(rotY), sY=Math.sin(rotY);
      let dx=cY*x + sY*z, dz=-sY*x + cY*z, dy=y;
      const cX=Math.cos(rotX), sX=Math.sin(rotX);
      let dy2=cX*dy - sX*dz;
      let dz2=sX*dy + cX*dz;
      const scale = 80;
      return {
        x: cv.width/2 + dx*scale,
        y: cv.height/2 - dy2*scale,
        depth: dz2
      };
    }

    function drawPiece(){
      ctx.clearRect(0,0,cv.width,cv.height);
      const cells = p.norm.map(c0=>{
        const pr = project(c0);
        return {c0,depth:pr.depth};
      }).sort((a,b)=>a.depth-b.depth);

      cells.forEach(d=>{
        faces.forEach(f=>{
          const pts = f.verts.map(v=>project([d.c0[0]+v[0],d.c0[1]+v[1],d.c0[2]+v[2]]));
          ctx.beginPath();
          ctx.moveTo(pts[0].x,pts[0].y);
          pts.slice(1).forEach(p2=>ctx.lineTo(p2.x,p2.y));
          ctx.closePath();
          ctx.fillStyle = shadeColor(p.color,f.shade);
          ctx.fill();
          ctx.strokeStyle="#333";
          ctx.stroke();
        });
      });
    }
    drawPiece();

    // drag to rotate view
    let drag=false, lx=0, ly=0;
    cv.addEventListener("mousedown",e=>{ drag=true; lx=e.clientX; ly=e.clientY; });
    window.addEventListener("mousemove",e=>{
      if(!drag) return;
      rotY += (e.clientX - lx)*0.01;
      rotX += (e.clientY - ly)*0.01;
      lx=e.clientX; ly=e.clientY;
      drawPiece();
    });
    window.addEventListener("mouseup",()=>drag=false);

    // select on click
    cv.addEventListener("click",()=>{
      document.querySelectorAll("canvas.piece").forEach(c=>c.classList.remove("selected"));
      if(selected===idx) selected=null;
      else { selected=idx; cv.classList.add("selected"); }
    });
  });

  // --- Solver grid & placement ---
  const solver = document.getElementById("solver"),
        sCtx   = solver.getContext("2d");
  solver.width = solver.height = 400;
  let sRotX=Math.PI/6, sRotY=-Math.PI/6;
  let dragG=false, glx=0, gly=0;

  const occupied = {};   // "x,y,z" -> piece idx
  const placements = []; // {idx, origin}

  function projectG(pt){
    let [x,y,z]=pt;
    const cY=Math.cos(sRotY), sY=Math.sin(sRotY);
    let dx=cY*x + sY*z, dz=-sY*x + cY*z, dy=y;
    const cX=Math.cos(sRotX), sX=Math.sin(sRotX);
    let dy2=cX*dy - sX*dz;
    let dz2=sX*dy + cX*dz;
    return {
      x: solver.width/2 + dx*50,
      y: solver.height/2 - dy2*50,
      depth: dz2
    };
  }

  function drawSolver(){
    sCtx.clearRect(0,0,solver.width,solver.height);
    // wireframe
    sCtx.strokeStyle="#888";
    for(let i=0;i<=3;i++)for(let j=0;j<=3;j++){
      let p0=projectG([0,i,j]), p1=projectG([3,i,j]);
      sCtx.beginPath(); sCtx.moveTo(p0.x,p0.y); sCtx.lineTo(p1.x,p1.y); sCtx.stroke();
      p0=projectG([i,0,j]); p1=projectG([i,3,j]);
      sCtx.beginPath(); sCtx.moveTo(p0.x,p0.y); sCtx.lineTo(p1.x,p1.y); sCtx.stroke();
      p0=projectG([i,j,0]); p1=projectG([i,j,3]);
      sCtx.beginPath(); sCtx.moveTo(p0.x,p0.y); sCtx.lineTo(p1.x,p1.y); sCtx.stroke();
    }
    // draw placed cubes
    const allCubes = [];
    placements.forEach(pl=>{
      const piece = pieces[pl.idx];
      piece.norm.forEach(c0=>{
        const wx=pl.origin[0]+c0[0],
              wy=pl.origin[1]+c0[1],
              wz=pl.origin[2]+c0[2];
        const pr=projectG([wx,wy,wz]);
        allCubes.push({wx,wy,wz,depth:pr.depth,color:piece.color});
      });
    });
    allCubes.sort((a,b)=>a.depth-b.depth);
    allCubes.forEach(d=>{
      faces.forEach(f=>{
        const nb=[d.wx+f.normal[0],d.wy+f.normal[1],d.wz+f.normal[2]].join(",");
        if(occupied[nb]!=null) return;
        const pts=f.verts.map(v=>projectG([d.wx+v[0],d.wy+v[1],d.wz+v[2]]));
        sCtx.beginPath();
        sCtx.moveTo(pts[0].x,pts[0].y);
        pts.slice(1).forEach(p2=>sCtx.lineTo(p2.x,p2.y));
        sCtx.closePath();
        sCtx.fillStyle=shadeColor(d.color,f.shade);
        sCtx.fill();
        sCtx.strokeStyle="#333";
        sCtx.stroke();
      });
    });
  }

  // rotate solver
  solver.addEventListener("mousedown",e=>{ dragG=true; glx=e.clientX; gly=e.clientY; });
  window.addEventListener("mousemove",e=>{
    if(!dragG) return;
    sRotY += (e.clientX-glx)*0.01;
    sRotX += (e.clientY-gly)*0.01;
    glx=e.clientX; gly=e.clientY;
    drawSolver();
  });
  window.addEventListener("mouseup",()=>dragG=false);

  // place on click with debug logging
  solver.addEventListener("click", e => {
    console.log("solver click; selected =", selected);
    if(selected==null) return;
    const rect=solver.getBoundingClientRect();
    const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
    let best=null, bd=Infinity;
    for(let x=0;x<3;x++)for(let y=0;y<3;y++)for(let z=0;z<3;z++){
      const pr=projectG([x,y,z]);
      const d=(pr.x-cx)**2+(pr.y-cy)**2;
      if(d<bd){ bd=d; best=[x,y,z]; }
    }
    const origin=best, norm=pieces[selected].norm;
    for(const c of norm){
      const wx=origin[0]+c[0], wy=origin[1]+c[1], wz=origin[2]+c[2];
      if(wx<0||wx>2||wy<0||wy>2||wz<0||w0>2) return;
      if(occupied[[wx,wy,wz].join(",")]!=null) return;
    }
    norm.forEach(c=>{
      occupied[[origin[0]+c[0],origin[1]+c[1],origin[2]+c[2]].join(",")]=selected;
    });
    placements.push({idx:selected,origin});
    document.querySelectorAll("canvas.piece").forEach(c=>c.classList.remove("selected"));
    selected=null;
    drawSolver();
  });

  drawSolver();
  </script>
</body>
</html>
