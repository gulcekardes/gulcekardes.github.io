<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Gülce Kardeş – Puzzles</title>
  <!-- Google Fonts: Volkorn & Mate (Volkorn for headings, Palatino for body)-->
  <link href="https://fonts.googleapis.com/css2?family=Volkorn:wght@400;700&family=Mate:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: Palatino, serif;
      background: #fafafa;
      overflow: hidden;
    }
    header {
      position: absolute;
      top: 0; width: 100%;
      background: white; padding: 1rem;
      text-align: center;
      z-index: 10;
      font-family: Volkorn, serif;
    }
    .nav-links a {
      margin: 0 10px;
      color: navy;
      text-decoration: none;
      font-size: 1.1rem;
    }
    .nav-links a.active {
      font-weight: bold;
    }
    #overlay {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.9);
      padding: 2rem 3rem;
      border: 2px solid #2c3e50;
      font-family: Volkorn, serif;
      font-size: 2rem;
      color: #2c3e50;
      display: none;
      z-index: 20;
    }
    canvas { display: block; } /* full‐screen three.js canvas */
  </style>
</head>
<body>

  <header>
    <div class="nav-links">
      <a href="index.html">Home</a>
      <a href="puzzles.html" class="active">Puzzles</a>
      <a href="https://scholar.google.com/citations?user=-io3rR0AAAAJ">Google Scholar</a>
    </div>
  </header>

  <div id="overlay">Solution found!</div>

  <!-- Three.js and controls from CDN -->
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.150.1/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.150.1/examples/js/controls/DragControls.js"></script>

  <script>
    // scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(8, 8, 8);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // orbit controls
    const orbit = new THREE.OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;

    // light
    scene.add(new THREE.AmbientLight(0xffffff, .6));
    const dir = new THREE.DirectionalLight(0xffffff, .8);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // transparent 3x3x3 frame
    const boxGeo = new THREE.BoxGeometry(3,3,3);
    const wire = new THREE.WireframeGeometry(boxGeo);
    const frame = new THREE.LineSegments(wire, new THREE.LineBasicMaterial({color:0x333333}));
    frame.position.set(0,1.5,0);
    scene.add(frame);

    // Soma piece definitions (arrays of [x,y,z])
    const piecesDef = [
      // V
      { coords:[[0,0,0],[1,0,0],[0,1,0],[0,0,1]], color:0xe6194B },
      // L
      { coords:[[0,0,0],[1,0,0],[2,0,0],[0,1,0]], color:0x3cb44b },
      // T
      { coords:[[0,0,0],[1,0,0],[2,0,0],[1,1,0]], color:0x4363d8 },
      // Z
      { coords:[[0,0,0],[1,0,0],[1,1,0],[2,1,0]], color:0xf58231 },
      // A (left arm)
      { coords:[[0,0,0],[1,0,0],[2,0,0],[0,1,0]], color:0x911eb4, rotate:true },
      // B (right arm)
      { coords:[[0,0,0],[1,0,0],[2,0,0],[2,1,0]], color:0x46f0f0 },
      // P
      { coords:[[0,0,0],[1,0,0],[0,1,0],[1,1,0]], color:0xf032e6 }
    ];

    // build piece meshes
    const pieceMeshes = [];
    piecesDef.forEach((pd, i) => {
      const group = new THREE.Group();
      pd.coords.forEach(c => {
        const cube = new THREE.Mesh(
          new THREE.BoxGeometry(1,1,1),
          new THREE.MeshStandardMaterial({color: pd.color})
        );
        cube.position.set(c[0], c[1], c[2]);
        group.add(cube);
      });
      // optional rotation for chirality
      if (pd.rotate) group.rotation.y = Math.PI/2;
      // initial placement: spread on right side
      group.position.set(5 + (i%2)*2, 0, -4 + Math.floor(i/2)*2);
      scene.add(group);
      pieceMeshes.push(group);
    });

    // DragControls
    const drag = new THREE.DragControls(pieceMeshes, camera, renderer.domElement);
    drag.addEventListener('dragstart', e => orbit.enabled = false);
    drag.addEventListener('dragend', e => {
      orbit.enabled = true;
      // snap to integer grid
      e.object.position.x = Math.round(e.object.position.x);
      e.object.position.y = Math.round(e.object.position.y);
      e.object.position.z = Math.round(e.object.position.z);
      checkSolution();
    });

    // track occupancy
    function checkSolution(){
      const occ = {};
      let count = 0;
      for (let i=0; i<pieceMeshes.length; i++){
        const mesh = pieceMeshes[i];
        const def = piecesDef[i];
        for (let c of def.coords){
          const wx = mesh.position.x + c[0];
          const wy = mesh.position.y + c[1];
          const wz = mesh.position.z + c[2];
          const key = `${wx}|${wy}|${wz}`;
          // inside 0≤x,y,z<3?
          if (wx<0||wx>2||wy<0||wy>2||wz<0||wz>2) return;
          if (occ[key]) return;       // overlap
          occ[key]=true;
          count++;
        }
      }
      if (count===27){
        document.getElementById('overlay').style.display='block';
      }
    }

    // render loop
    function animate(){
      requestAnimationFrame(animate);
      orbit.update();
      renderer.render(scene, camera);
    }
    animate();

    // resize handler
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
